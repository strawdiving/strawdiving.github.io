[{"url":"/2018/08/27/JointJS结构分析/JointJS结构分析/","content":"## JointJS的结构分析\n\nJointJS库导出三个全局变量：joint，v和g。\n\n- **v** —— 是一个称为Vectorizer的轻量级SVG库，可以使SVG文档的操作更容易。JointJS在内部使用此库。通常情况下，除了高级用途之外，用户不需要使用此库。\n- **g **—— JointJS内部使用的轻量级库，提供很多有用的几何操作。用户一般不需要使用此库，但是当你需要在应用程序中执行几何操作时，这个库会很实用。\n- **joint **—— joint命名空间包含了用于构建图表的所有对象。\n\n## Joint\n\nJointJS使用Backbone MVC库构建，Backbone提供了Model，View，Collection——构建应用程序的骨架。构建图表的所有对象都包含在joint命名空间中，我们对照Backbone的结构来分析joint的主要结构。\n\n### Backbone的Model,View,Collection\n\nBackbone.js为Web应用程序提供了结构，为models模型提供键值绑定和自定义事件，为collections提供丰富的API，为views视图提供声明式事件处理。\n\nBackbone中，将数据表示为Models，可以创建、验证、销毁以及保存到服务器。当UI操作引起model的属性发生变化，model会触发一个“change\"事件。\n\n所有显示model状态的Views都可以被通知更改，以便能做出相应的响应，从而使用新信息重新呈现自己。\n\n#### 1. Models and Views\n\n![Model-View Separation.](http://backbonejs.org/docs/images/intro-model-view.svg)\n\nBackbone可以将业务逻辑和用户界面分开。\n\n##### Models\n\n- 编排数据和业务逻辑\n- 从服务器加载和保存\n- 数据更改时发送事件\n\nModel管理数据属性的内部表，并在修改任何数据时触发“change”事件。模型负责与持久层同步数据 - 通常是具有后备数据库的REST API。将模型设计为原子可重用对象，其中包含用于处理其特定数据位的所有有用函数。模型应该能够在整个应用程序中传递，并在需要数据位的任何地方使用。\n\n##### Views\n\n- 侦听更改并渲染UI\n- 处理用户输入和交互\n- 将捕获的输入发送给model\n\nView是用户界面的原子块。它通常渲染来自某个或某些模型的数据——但是视图也可以是单独的无数据的UI块。Models通常应该不知道views。相反，view会侦听model的“change”事件，并给予适当的反应或重新渲染。\n\n#### 2. Collections\n\n![Model Collections.](http://backbonejs.org/docs/images/intro-collections.svg)\n\nCollection帮助处理一组关联models，处理加载models和保存新models到服务器的工作，并提供对models list执行聚合或计算的帮助函数。除了其自身的事件，collection还可以通过对其中的model发生的所有事件进行代理，来侦听其中任何model发生的事件。\n\n### joint的主要模块\n\njoint的主要模块就是按照Backbone的Model，View，Collection的骨架结构来构建应用程序的。\n\n1. Models\n\nmodel是核心，包含交互式数据及围绕它的大部分逻辑，如验证、转变、计算属性、访问控制等。\n\nCell，Element，Link和Graph属于Model，继承关系如下图所示：\n\n![backbone.model](backbone.model.PNG)\n\njoint.dia.Cell和joint.dia.Graph都继承自Backbone的Model，并添加了各自的附加属性和方法。\n\njoint.dia.Element和joint.dia.Link都继承自joint.dia.Cell，并添加了一些elements/links特定的属性和方法。joint.shapes在joint.dia.Element和joint.dia.Link的基础上进行扩展来创建自定义形状。\n\n##### joint.dia.Cell\n\n继承自BackBone.Model，图表cells的基本模型。这是一个具有一些附加属性和方法的Backbone Model，具有唯一标识符，每个cell都有一个存储在id属性中的唯一ID。\n\n##### joint.dia.Element\n\n图表元素的模型。它从joint.dia.Cell继承，并添加了一些特定于元素的附加属性和方法。这些属性可以分为三组：\n\n- Geometry\n\n元素的坐标存储在position属性(具有x和y键的对象)中；旋转角度存储在angle属性中, 以度为单位，旋转原点始终被认为是元素的中心.；大小存储在size属性中，该属性是具有width和height键的对象。\n\nposition/angle/size可以使用常规Backbone set（）/ get（）方法或通过translate/rotate/resize方法直接访问或设置.\n\n- Presentation\n\n另一个重要属性是attrs，它是一个对象，其中的\n\n1. key: 与子元素匹配的selectors\n2. value: 将在子元素上设置的SVG属性。\n\n在MDN上可以找到SVG属性列表和它们的描述。\n\n值得注意的是，每个joint.dia.Element定义了一个SVG markup，然后由joint.dia.ElementView使用该markup将元素渲染/呈现给paper。\n\n```javascript\n// eg. joint.shapes.basic.Rect元素\njoint.shapes.basic.Generic.define('basic.Rect', {\n        attrs: { // 设置attrs属性\n            'rect': {  // 设置矩形子元素的SVG属性，与markup中的矩形子元素对应\n                fill: '#ffffff',\n                stroke: '#000000',\n                width: 100,\n                height: 60\n            },\n            'text': {  // 设置文本子元素的SVG属性，与markup中的text子元素对应\n                fill: '#000000',\n                text: '',\n                'font-size': 14,\n                'ref-x': .5,\n                'ref-y': .5,\n                'text-anchor': 'middle',\n                'y-alignment': 'middle',\n                'font-family': 'Arial, helvetica, sans-serif'\n            }\n        }\n    }, {\n        //joint.shapes.basic.Rect元素定义的SVG markup\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect/></g><text/></g>'\n    });\n```\n\n注：修改属性时不建议直接更改attrs对象，建议使用attr方法。\n\nz属性指定SVG DOM中元素的堆栈顺序。具有较高z等级的元素位于具有较低z等级的元素的前面。（这也适用于具有完全相同属性的link）\n\n- Nesting\n\n元素的最后两个属性是embeds和parent。这两个属性与包含或包含在其他元素中构成分层结构的元素有关。embeds是嵌入在元素内部的cell ID的列表，parent是embedded 元素的父元素的id。当一个父元素被translate时，它的所有孩子也会被translate。\n\n##### joint.dia.Link\n\n图表link的基本模型，继承自joint.dia.Cell，并添加了一些links特定的属性和方法。\n\nlinks有两个关键属性：source和target，定义了link的起点和终点。\n\n##### joint.shapes\n\n提供了一些预定义的即时可用的形状（shapes）。在joint.shapes.standard中，提供了最常见形状（Rectangle，Circle，Path，Polygon，Image，Link等）的即用型高性能版本。形状可以原样使用，也可以在其基础上进行扩展来创建自定义形状。\n\n##### joint.dia.Graph\n\n是包含graph的所有cells（elements和links）的模型，是一个Backbone Model。\n\njoint.dia.GraphCells继承自Backbone.Collection，是所有cells的collection，存储在graph的cells属性中。\n\ngraph是所有JointJS图表背后的强大数据模型。它不仅为directed graph提供了高效的存储，而且还为遍历graphs提供了有用的算法。\n\n2. Views\n\nBackbone的View并不是模板本身，却是一些控制类，它们处理模型的表现。\n\nCellView，ElementView，LinkView和Paper属于View，继承关系如下图所示：\n\n![Backbone.View](Backbone.View.png)\n\njoint.MVC.View继承并扩展了Backbone.View，包含了JointJS中的视图的基本方法和属性。joint.dia.CellView和joint.dia.Paper都继承自joint.MVC.View。\n\njoint.dia.Paper是joint.dia.Graph的视图，负责渲染关联的graph中的所有cells。\n\njoint.dia.CellView是joint.dia.Cell的视图；joint.dia.ElementView和joint.dia.LinkView分别是joint.dia.Element和joint.dia.Link的视图。\n\n##### joint.dia.CellView\n\njoint.dia.Cell模型的view。继承自Backbone.View并负责：\n\n- 渲染paper内的cell；\n- 处理cell的pointer事件；\n- 提供各种处理cell的方法（可视化）\n\n##### joint.dia.ElementView\n\njoint.dia.Element模型的视图，继承自 joint.dia.cellView。负责：渲染paper内的元素 ；处理元素的pointer事件 ；提供各种处理元素的方法（可视化）。\n\n##### joint.dia.LinkView\n\njoint.dia.Link模型的视图。继承自joint.dia.CellView，负责：\n\n- 渲染paper内的link ；\n- 处理link的pointer事件 ；提供各种处理link的方法（可视化）。\n\n##### joint.dia.Paper\n\njoint.dia.Paper是joint.dia.Graph模型的视图，继承自 joint.mvc.View（继承自Backbone.View），当paper与graph相关联时，paper会确保添加到graph中的所有cells都自动渲染。\n\n#### 3. Collection\n\n![backbone.collection](backbone.collection.PNG)\n\n**joint.dia.GraphCells**继承自Backbone.Collection，是graph中的cells的有序集合，存储在graph的“cells”属性中。\n\nBackbone.Collection是models的有序集合，可以绑定“change\"事件，以便collection中的任何model被修改时通知。collection中的model触发的任何事件也将直接在collection上触发，允许监听collection中任何model中特定属性的更改。\n\n### 其他模块\n\n##### joint.dia.attributes\n\nJointJS中的属性（attributes）定义了如何在element和link views中呈现图形元素(graphics elements)。可以使用所有标准SVG样式属性。\n\n此外，JointJS定义了新的所谓“特殊”属性，并允许程序员定义自己的属性。\n\n##### joint.env\n\n提供接口，让用户添加自定义功能检测测试，用于测试浏览器是否支持给定功能。\n\n##### joint.highlighters\n\n用来为元素提供视觉强调，例如在用户交互期间，对元素进行高亮/ 非高亮处理。\n\n##### joint.layout\n\n图表的自动布局，该插件在内部使用开源（MIT许可证）Dagre库。它提供了一个包装器，以便您可以直接在JointJS图上调用布局。\n\n注意，如果您希望使用layout.DirectedGraph插件，则必须同时包含Dagre和Graphlib库作为依赖关系。\n\n##### joint.util\n\n提供了一些通用的便利函数，供JointJS内部使用。\n\n"},{"title":"JointJS使用入门","url":"/2018/08/24/JointJS/JointJS/","content":"\n## Introduction\n\nJointJS图表库可以让你仅仅依赖JavaScript和SVG，就能为所有现代浏览器创建完全交互式的图表工具。它的MVC（其实更多是MV）架构将graph, element 和 link模型与它们的渲染分离开来，这使得JointJS更易于集成到后端应用程序中。\n\nJointJS使用Backbone MVC库构建，并使用jQuery和Lodash。\n\nJointJS中的图表由Graph模型（joint.dia.Graph）表示，您可以在其中添加cells的模型 ——可以是Elements（joint.dia.Element的子类型），也可以是Links（joint.dia.Link的子类型）。为了显示图表，需要将其附加到Paper视图（joint.dia.Paper）。从版本0.6开始，您只需要处理模型，而不用处理视图；paper会从graph模型提供的数据中生成ElementViews和LinkViews。该体系结构如下图所示：\n\n![](http://resources.jointjs.com/tutorials/joint/tutorials/images/arch.png)\n\nJointJS提供了常见几何形状（如矩形、圆、椭圆）的可视化库，以及几种著名的图表语言（ERD，OrgChart，FSA，UML，PN，DEVS ......）所包含的大量现成组件。JointJS框架的设计注重模块化，这使高级用户可以轻松创建自己的形状并使用自定义插件扩展内置功能。\n\nRappid是JointJS的商业版本，提供了许多预制插件，可通过小部件，交互组件和其他形状（如BPMN图）扩展其功能。  \n\n## 创建基础JointJS图表\n\n官网给出的的示例，效果如下：\n\n![](JointJS/helloworld.png)\n\n该程序执行JointJS应用程序需要执行的所有操作以生成可视输出：\n\n1. **包含JointJS及其依赖**\n2. **定义一个graph和一个paper**\n3. **创建2个矩形elements**\n4. **创建一个link来连接elements**\n\n下面，我们一步一步来创建这个基础的JointJS图表。\n\n### step 1.  Installation\n\n要运行JointJS应用程序，必须将JointJS库及其依赖项包含在页面的源HTML中。\n\n1. 方式一：使用CDN，链接到JointJS，jQuery，Lodash和Backbone所需的源文件。\n\n看官方的例子：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/jointjs/2.1.0/joint.css\" />\n</head>\n<body>\n    <!-- content -->\n    <div id=\"myholder\"></div>\n\n\t<!-- 1.包含JointJS及其依赖（jQuery,lodash,Backbone）-->\n    <!-- dependencies-->\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.3.3/backbone.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jointjs/2.1.0/joint.js\"></script>\n\n    <!-- code -->\n    <script type=\"text/javascript\">\n    </script>\n</body>\n</html>\n```\n\n1. 方式二：本地安装JointJS。如果已经安装了NPM，运行 \n\n   ```javascript\n   npm install --save jointjs\n   ```\n\n   然后，在生成的node_modules文件夹中的各自文件夹中找到所有必需的源文件。代码段将如下所示：\n\n   ```html\n   <!DOCTYPE html>\n   <html>\n   <head>\n       <link rel=\"stylesheet\" type=\"text/css\" href=\"node_modules/jointjs/dist/joint.css\" />\n   </head>\n   <body>\n       <!-- content -->\n       <div id=\"myholder\"></div>\n   \n       <!-- dependencies -->\n       <script src=\"node_modules/jquery/dist/jquery.js\"></script>\n       <script src=\"node_modules/lodash/index.js\"></script>\n       <script src=\"node_modules/backbone/backbone.js\"></script>\n       <script src=\"node_modules/jointjs/dist/joint.js\"></script>\n   \n       <!-- code -->\n       <script type=\"text/javascript\">\n       </script>\n   </body>\n   </html>\n   ```\n\n   现在JointJS已经包含在我们的页面中，接下来可以开始构建我们的图表了。\n\n   ### step 2.  Create graph & paper\n\n   **所有有用的JointJS应用程序都需要有graph和paper**。graph包含了对图表的的所有组件的引用，paper负责图表的渲染。\n\n   在code部分，script标签中，创建一个graph对象和一个paper对象。\n\n   ```javascript\n    <!-- code -->\n       <script type=\"text/javascript\">\n   \n           var graph = new joint.dia.Graph;\n   \n           var paper = new joint.dia.Paper({\n               el: document.getElementById('myholder'),\n               model: graph,\n               width: 600,\n               height: 100,\n               gridSize: 1\n           });\n           \n           var rect = new joint.shapes.standard.Rectangle();\n           rect.position(100, 30);\n           rect.resize(100, 40);\n           rect.attr({\n               body: {\n                   fill: 'blue'\n               },\n               label: {\n                   text: 'Hello',\n                   fill: 'white'\n               }\n           });\n           rect.addTo(graph);\n   \n           var rect2 = rect.clone();\n           rect2.translate(300, 0);\n           rect2.attr('label/text', 'World!');\n           rect2.addTo(graph);\n   \n           var link = new joint.shapes.standard.Link();\n           link.source(rect);\n           link.target(rect2);\n           link.addTo(graph);\n       </script>\n   ```\n\n   Graph模型通常在JointJS JavaScript代码的第一行定义。在我们的代码中，我们将对它的引用保存为var graph。为了渲染我们的cells（elements 和 links），我们需要将它们添加到graph中（除非我们添加我们的cells，否则图表是不知道它们的存在的）。在示例中，我们使用addTo（）函数执行将cells添加到graph中，也可以使用graph.addCells（）函数执行此操作。\n\n   通常，paper view在graph定义之后直接指定，我们使用了一个选项对象来创建paper，并将其保存为var paper。在五个选项中，有两个定义了关键的paper属性，这些属性将渲染过的paper一边与我们的HTML关联起来，一边和我们的JointJS数据（element和link模型）关联起来：\n\n   - el，paper将要渲染成的HTML元素\n   - graph，我们想要在paper中渲染呈现的Graph模型\n\n   其他的三个选项指定了paper的表示属性。本例中，包含：\n\n   - width和height，渲染的paper的尺寸（以像素为单位）\n   - gridSize，元素对齐的网格大小。影响元素移动的粒度。\n\npaper还有很多属性，允许自定义几乎所有关于paper渲染的内容。此外，paper还提供了很多函数，可以改变paper的呈现方式。可参考 [Paper Attributes demo](http://resources.jointjs.com/demo/paper)和 [Multiple Papers tutorial](http://resources.jointjs.com/tutorials/joint/tutorials/multiple-papers.html) \n\n### step 3.  Create Elements\n\n```javascript\n <!-- code -->\n    <script type=\"text/javascript\">\n\n       /* 创建graph */\n\t   /* 创建paper */\n       \n       /* 创建elements */\n        var rect = new joint.shapes.standard.Rectangle();\n        rect.position(100, 30); //设置元素原点的位置\n        rect.resize(100, 40); //设置元素的尺寸\n        rect.attr({\n            body: { //<rect> SVGElement的选择器\n                fill: 'blue'\n            },\n            label: { //<text> SVGElement的选择器\n                text: 'Hello',\n                fill: 'white'\n            }\n        });\n        rect.addTo(graph);\n\n        var rect2 = rect.clone(); //克隆现有元素，包括其位置，尺寸和属性\n        rect2.translate(300, 0); //将元素沿两个坐标轴移动指定的距离\n        rect2.attr('label/text', 'World!');// 分配值 ‘World!’给 ‘label/text’\n        rect2.addTo(graph); //将元素添加到graph中\n\n\t  /* 创建link来连接2个elements */\n        var link = new joint.shapes.standard.Link();\n        link.source(rect);\n        link.target(rect2);\n        link.addTo(graph);\n    </script>\n```\n\n在创建了graph和paper之后，我们又创建了2个矩形element以及连接这两个element的link。\n\n使用element的基本思想：\n\n- **首先，通过调用element构造函数来创建一个element**\n- **然后，在element上调用不同的方法来设置其properties属性（position，size，attributes......）**\n- **最后，将设置好的elements添加到graph中**\n\n在本例中，两个elements是 joint.shapes.standard.Rectangle 的实例，JointJS中的标准形状库（standard shape library）中包含了很多现成的element定义（如Ellipse, Embedded Image...等），可以直接使用。高级用户可以通过扩展基本的joint.dia.Element类来自定义elements。\n\n#### Element Styling 元素样式\n\n改变element样式的最重要的函数：\n\n- element.attr()——以编程方式将SVG属性直接分配给形状（shape）的markup对应的SVGElements（CSS样式仍可以在此处定义的样式之上使用，并且它们具有更高的优先级）\n\n当使用一个对象作为参数调用element.attr（）时，对象的keys是对应于形状的markup的SVGElements的选择器；如果只需要改变一个值，你也可以用两个参数调用element.attr（），第一个是“selector / attribute”形式的属性路径，第二个是要分配的值，如\n\n```\n  rect2.attr('label/text', 'World!');\n```\n\nJointJS能够处理所有标准SVG属性，但请注意，我们强烈建议大家使用camelCase版本的属性名称以保持一致性，以避免在属性名称键中使用引号。\n\n本例中使用的 joint.shapes.standard.Rectangle形状定义了2个选择器：\n\n- body，即< rect > SVGElement本身\n- label，即shape内的< text > SVGElement\n\n其他的element有它们自己的选择器名称，详细信息可以参阅joint.shapes.standard文档。\n\n本例中，为rect元素的body选择器分配了一个 fill 颜色属性，而 label 选择器的 text 内容也设置为'Hello'。\n\n```javascript\nrect.attr({\n    body: { // selector for the <rect> SVGElement\n        fill: 'blue'\n    },\n    label: { // selector for the <text> SVGElement\n        text: 'Hello',\n        fill: 'white'\n    }\n});\n```\n\nrect2元素，label是< text > SVGElement的选择器，text是我们要修改的属性。\n\n```js\n rect2.attr('label/text', 'World!');// 分配值‘World!’给‘label/text’\n```\n\n相当于\n\n```javascript\nrect2.attr('label',{text: 'World!'});\n```\n\n也相当于\n\n```javascript\nrect2.attr({label: {text:'World!'}});\n```\n\n### step 4.  Create Links to Connect Elements\n\n```javascript\n var link = new joint.shapes.standard.Link();\n        link.source(rect);\n        link.target(rect2);\n        link.addTo(graph);\n```\n\nJointJS图表的另一个重要的构建快是links。links的使用类似于elements:\n\n- **首先，通过调用link的构造函数来创建一个link**\n- **然后，在link上调用不同的方法来设置其properties属性（source & target, vertices, router & connector, attributes, labels...）**\n- **最后，将设置好的link添加到graph中**\n\n在本例中，link是joint.shapes.standard.Link的实例，标准形状库（standard shape library）包含可在文档中使用的其他几种现成的link定义（例如DoubleLink和ShadowLink）。此外，高级用户可以通过扩展基本的joint.dia.Link类来创建自己的link定义。\n\n本例中展示了两个必需的Link方法：\n\n- link.source()和link.target()——设置了link的source/target。要将link连接到element，将element传递给函数（如示例中所示）。\n\n#### Link Styling 链接样式\n\nlink样式与element样式类似：\n\n- link.attr()——以编程方式将SVG属性直接分配给形状（shape）的markup对应的SVGElements（CSS样式仍可以在此处定义的样式之上使用，并且它们具有更高的优先级）\n\n当使用一个对象作为参数调用element.attr（）时，对象的keys是对应于形状的markup的SVGElements的选择器；如果只需要改变一个值，你也可以用两个参数调用element.attr（），第一个是“selector / attribute”形式的属性路径，第二个是要分配的值。\n\n本例中使用的 joint.shapes.standard.Link形状定义了2个选择器：\n\n- line，即link的可见的< path> SVGElement\n- wrapper，line下方的更宽，更透明的< path> SVGElement元素，使link更易于交互\n\n其他的element有它们自己的选择器名称，详细信息可以参阅joint.shapes.standard文档。\n\n例如，可以通过改变line选择器上的stroke颜色属性来改变link的颜色：\n\n```javascript\nlink.attr('line/stroke', 'orange');\n```\n\n通过将单个对象参数传递给link.attr可以实现相同的效果：\n\n```javascript\nlink.attr({\n    line: { // selector for the visible <path> SVGElement\n        stroke: 'orange' // SVG attribute and value\n    }\n});\n```\n\n有两个特殊属性用来指定link的箭头： sourceMarker和targetMarker，箭头的“type”可以是任何有效的SVGElement类型，常用的有path和image。\n\n```javascript\nlink.attr({\n    line: {\n        sourceMarker: { // hour hand\n            'type': 'path',\n            'd': 'M 20 -10 0 0 20 10 Z'\n        },\n        targetMarker: { // minute hand\n            'type': 'path',\n            'stroke': 'green',\n            'stroke-width': 2\n            'fill': 'yellow',\n            'd': 'M 20 -10 0 0 20 10 Z'\n        }\n    }\n});\n```\n\nJointJS还支持Link的：\n\n- vertices—— 用户定义的，link应该在从source到target的途中通过的一系列顶点\n- router—— router是一个获取link的vertices顶点数组，并在必要时添加额外的点以创建具有所需特征的route的函数，如正交router等\n- connector——负责在peper上渲染link的路径的功能，它采用router提供的route点矩阵，构造一系列SVGPathElement路径数据命令，以创建具有所需特征的路径;\n- labels——设置link的labels数组。labels具有markup，attrs和position属性。\n\n详见官方文档。","tags":["JointJS"]}]